require 'tempfile'
require 'json'

namespace :cul do
  namespace :wp do
    namespace :migrate do

      desc "Copies the WordPress installation from one environment to another (e.g. prod to dev)"
      task :copy_from do
        # Need to store path as local variable so it can be referenced in `on roles(:web) do` portion of script
        path_to_allowed_upload_types_plugin = cul_allowed_upload_types_plugin_path

        require_cap_params!([:wp_docroot, :wp_content_path])

        if fetch(:multisite, false)
          puts "Since this is a multisite, you'll need to specify the source instance multisite url to continue:"
          set :source_site_multisite_url, ask('source multisite full install url (e.g. https://blogs.cul.columbia.edu)')
          fetch(:source_site_multisite_url)

          puts "And you'll also need to specify the destination instance multisite url to continue:"
          set :destination_site_multisite_url, ask('destination multisite full install url (e.g. https://blogs-dev.cul.columbia.edu)')
          fetch(:destination_site_multisite_url)
        end

        # TODO: Verify that destination wordpress has already had the setup and deploy tasks run for it
        set :src_wp_docroot, ask("server path to source WordPress installation (to copy from)")
        #set :src_wp_docroot, '/cul/cul0/lito/vmounts/haydn/var-www/kennedyprize/html'
        #set :src_wp_docroot, '/cul/cul0/ldpd/culblogs/prod/ssl-html'

        # Confirm operation because it is destructive
        puts "\nWARNING: This operation will obliterate all content in environment [#{fetch(:stage)}] and replace it with content from [#{fetch(:src_wp_docroot)}]."
        puts "Are you sure you want to continue?"
        set :confirm, ask('"y" or "yes" to continue')
        unless ['y', 'yes'].include?(fetch(:confirm))
          puts 'Copy operation has been cancelled because neither "y" nor "yes" were entered.'
          next
        end

        # Enter maintenance mode
        invoke 'cul:wp:enable_maintenance_mode'

        # Check WP version on source and destination WordPress instances
        failure = false
        on roles(:web) do
          within fetch(:src_wp_docroot) do
            # Ensure that source WordPress is running the latest version
            result = capture :wp, (fetch(:multisite, false) ? "--url=#{fetch(:source_site_multisite_url)}" : ''), 'core', 'check-update'
            unless result.index('Success')
              puts 'Could not copy from source WordPress because it is not running the latest version of WordPress. Please update source before running a copy operation.'
              failure = true
            end
          end
        end
        next if failure # End if the previous checks failed

        path_to_list_of_files_to_copy = ''

        on roles(:web) do
          # In source site's wp-content directory, generate file list to copy
          within File.join(fetch(:src_wp_docroot), 'wp-content') do
            # We're going to be copying wp-content in two parts
            # 1. Everything else under wp-content EXCEPT uploads, blogs.dir,
            # plugins, themes, mu-plugins
            # 2. Everything under uploads AND wpblogs.dir with
            # cul-allowed-upload-types file extension filter applied

            # Generate two find commands for the above searches
            find_non_upload_dirs = '. -type f ' +
              # EXCLUDE plugins, themes, mu-plugins, uploads, and blogs.dir
              "-not \\( -path './plugins/*' -o -path './mu-plugins/*' -o -path './themes/*' -o -path './uploads/*' -o -path './blogs.dir/*' \\) " +
              # EXCLUDE certain unwanted files and paths
              "-a -not \\( -name '.nfs*' \\) " +
              "-a -not \\( -path '*/.git*' -o -path '*/.svn*' -o -path '*/.hg*' \\) "

            find_upload_dirs = '. -type f ' +
              # INCLUDE ONLY uploads and blogs.dir
              "\\( -path './uploads/*' -o -path './blogs.dir/*' \\) " +
              # EXCLUDE certain unwanted files and paths
              "-a -not \\( -name '.nfs*' \\) " +
              "-a -not \\( -path '*/.git*' -o -path '*/.svn*' -o -path '*/.hg*' \\) " +
              # INCLUDE ONLY certain file extensions
              "-a \\( " + JSON.parse(capture(:wp, (fetch(:multisite, false) ? "--url=#{fetch(:source_site_multisite_url)}" : ''), 'eval', '"echo cul_allowed_upload_file_extensions_as_json();"')).map{ |allowed_file_extension|
                "-iname '*.#{allowed_file_extension}'"
              }.join(' -o ') + " \\) "

            path_to_list_of_files_to_copy = '/tmp/WP' + fetch(:wp_docroot).gsub('/', '-') + '-' + Time.now.to_i.to_s + '-files.txt'
            execute :find, find_non_upload_dirs, ' > ', path_to_list_of_files_to_copy
            execute :find, find_upload_dirs, ' >> ', path_to_list_of_files_to_copy

            # Print out which files won't be copied
            files_not_copied = capture(:comm, '-23', "<(find . -type f \\( -path './uploads/*' -o -path './blogs.dir/*' \\) | sort)", "<(find #{find_upload_dirs} | sort)")

            puts (
              "The following files will not be copied:\n" +
              "-------------------------\n" +
              "./plugins\n" +
              "./mu-plugins\n" +
              "./themes\n" +
              files_not_copied + "\n" +
              "-------------------------"
            )
          end

          # For destination wordpress, delete and recreate the wp-content directory
          execute :rm, '-rf', fetch(:wp_content_path)
          execute :mkdir, fetch(:wp_content_path)

          # Copy wp-content files (from path_to_list_of_files_to_copy) from source WP to destination WP
          # Note that because we have the '--copy-links' flag below, we're transforming all symlinks into real file copies
          rsync_params = [
            '--recursive',
            '--perms',
            '--times',
            '--devices',
            '--specials',
            '--copy-links',
            '--prune-empty-dirs'
          ]

          # we're only copying files from the given file list
          rsync_params << "--files-from=#{path_to_list_of_files_to_copy}"
          # src directory (--files-from values are relative to this src directory)
          rsync_params << File.join(fetch(:src_wp_docroot), 'wp-content/')
          # dest directory
          rsync_params << fetch(:wp_content_path) + '/'

          puts 'Copying wp-content. This may take a while for sites with a lot of uploads...'

          execute :rsync, *rsync_params

          # Next, create symlinks to repo-managed plugins and themes, which will also recreate plugins, mu-plugins, and themes directories

          within fetch(:wp_docroot) do
            # Regenerate symlinks
            invoke 'cul:wp:symlink_custom_plugins_and_themes'
          end

          # Now it's time to copy the database

          db_export_tempfile_path = ''

          within fetch(:src_wp_docroot) do
            # On source WordPress...

            puts 'Exporting database from source site. This may take a while for large sites...'
            # Export source WP DB to a temporary file
            db_export_tempfile_path = Dir::Tmpname.make_tmpname '/tmp/', 'db_export_tempfile.sql'
            execute :wp, (fetch(:multisite, false) ? "--url=#{fetch(:source_site_multisite_url)}" : ''), 'db', 'export', db_export_tempfile_path
          end

          within fetch(:wp_docroot) do
            # On destination WordPress...

            puts 'Importing database. This may take a while for large sites...'

            # Drop all tables
            execute :wp, 'db', 'reset', '--yes'

            # Read in db file
            execute :wp, 'db', 'import', db_export_tempfile_path

            # Delete db file now that we're done with it
            execute :rm, db_export_tempfile_path

            # Invoke searchreplace task to update URL
            puts "\nYou'll probably want to run the cul:wp:searchreplace command now, since it's likely that your WP URL differs between environments."
            puts "Do you want to run a search and replace operation?"
            set :confirm_searchreplace, ask('"y" or "yes" to continue')
            if ['y', 'yes'].include?(fetch(:confirm_searchreplace))
              invoke 'cul:wp:searchreplace'
            else
              puts '- Skipping search and replace because neither "y" nor "yes" were entered.'
            end
          end

          # Next, install all plugins and themes from src wordpress, matching all versions and active vs. inactive plugin and theme states

          data_for_plugins = []
          data_for_themes = []

          # Within src wp instance, get list of all plugins and themes with version
          within File.join(fetch(:src_wp_docroot)) do
            data_for_plugins = JSON.parse(capture(:wp, (fetch(:multisite, false) ? "--url=#{fetch(:source_site_multisite_url)}" : ''), 'plugin', 'list', '--fields=name,version,status', '--format=json'))
            data_for_themes = JSON.parse(capture(:wp, (fetch(:multisite, false) ? "--url=#{fetch(:source_site_multisite_url)}" : ''), 'theme', 'list', '--fields=name,version,status', '--format=json'))
          end

          # Within dest wp instance, install specifically versioned plugins and themes
          within File.join(fetch(:wp_docroot)) do
            # Get list of repo-managed plugins and themes so that we don't attempt to overwrite these directories
            repo_managed_plugin_names = fetch(:wp_custom_plugins, {}).keys
            repo_managed_theme_names = fetch(:wp_custom_themes, {}).keys

            puts "Downloading new copies of non-repo-managed plugins and themes..."

            data_for_plugins.delete_if{|plugin_info| repo_managed_plugin_names.include?(plugin_info['name']) }.each do |plugin_info|
              name = plugin_info['name']
              version = plugin_info['version']
              status = plugin_info['status']

              case status
              when 'active'
                execute :wp, (fetch(:multisite, false) ? "--url=#{fetch(:destination_site_multisite_url)}" : ''), 'plugin', 'install', name, "--version=#{version}", '--activate'
              when 'active-network'
                execute :wp, (fetch(:multisite, false) ? "--url=#{fetch(:destination_site_multisite_url)}" : ''), 'plugin', 'install', name, "--version=#{version}", '--activate-network'
              when 'inactive'
                execute :wp, (fetch(:multisite, false) ? "--url=#{fetch(:destination_site_multisite_url)}" : ''), 'plugin', 'install', name, "--version=#{version}"
              when 'must-use'
                puts "--- WARNING: must-use plugin #{name} was not migrated over.  It should be put in your blog's repository and deployed through a regular deployment."
              end
            end

            data_for_themes.delete_if{|theme_info| repo_managed_theme_names.include?(theme_info['name']) }.each do |theme_info|
              name = theme_info['name']
              version = theme_info['version']
              status = theme_info['status']

              case status
              when 'active'
                execute :wp, (fetch(:multisite, false) ? "--url=#{fetch(:destination_site_multisite_url)}" : ''), 'theme', 'install', name, "--version=#{version}", '--activate'
              when 'inactive', 'parent'
                execute :wp, (fetch(:multisite, false) ? "--url=#{fetch(:destination_site_multisite_url)}" : ''), 'theme', 'install', name, "--version=#{version}"
              end
            end
          end

          within fetch(:wp_docroot) do
            # Make docroot readable and executable for "other" user so nginx, which runs as "nobody", can read
            # Use -L flag because we want to follow symlinks. The whole deployment relies on symlinks.
            execute :find, '-L', File.join(fetch(:wp_docroot), 'wp-content'), '-type d -exec chmod o+rx "{}" \;'
            execute :find, '-L', File.join(fetch(:wp_docroot), 'wp-content'), '-type f -exec chmod o+r "{}" \;'
            # Make sure that wp-config file is not world readable
            execute :chmod, 'o-r', shared_path.join('wp-config.php')
          end

        end
      end

      after 'cul:wp:migrate:copy_from', 'cul:wp:disable_maintenance_mode'

    end
  end
end
