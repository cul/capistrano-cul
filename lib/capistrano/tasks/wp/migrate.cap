require 'tempfile'
require 'json'

namespace :cul do
  namespace :wp do
    namespace :migrate do

      desc "Copies the WordPress installation from one environment to another (e.g. prod to dev)"
      task :copy_from do
        # Need to store path as local variable so it can be referenced in `on roles(:web) do` portion of script
        path_to_allowed_upload_types_plugin = cul_allowed_upload_types_plugin_path

        require_cap_params!([:wp_docroot, :wp_content_path])

        if fetch(:multisite, false)
          puts "Since this is a multisite, you'll need to specify the source instance multisite url to continue:"
          set :source_site_multisite_url, ask('source multisite full install url (e.g. https://blogs.cul.columbia.edu)')
          fetch(:source_site_multisite_url)

          puts "And you'll also need to specify the destination instance multisite url to continue:"
          set :destination_site_multisite_url, ask('destination multisite full install url (e.g. https://blogs-dev.cul.columbia.edu)')
          fetch(:destination_site_multisite_url)
        end

        # TODO: Verify that destination wordpress has already had the setup and deploy tasks run for it
        set :src_wp_docroot, ask("server path to source WordPress installation (to copy from)")
        #set :src_wp_docroot, '/cul/cul0/lito/vmounts/haydn/var-www/kennedyprize/html'
        #set :src_wp_docroot, '/cul/cul0/ldpd/culblogs/prod/ssl-html'

        # Confirm operation because it is destructive
        puts "\nWARNING: This operation will obliterate all content in environment [#{fetch(:stage)}] and replace it with content from [#{fetch(:src_wp_docroot)}]."
        puts "Are you sure you want to continue?"
        set :confirm, ask('"y" or "yes" to continue')
        unless ['y', 'yes'].include?(fetch(:confirm))
          puts 'Copy operation has been cancelled because neither "y" nor "yes" were entered.'
          next
        end

        # Enter maintenance mode
        invoke 'cul:wp:enable_maintenance_mode'

        # Check WP version on source and destination WordPress instances
        on roles(:web) do
          within fetch(:src_wp_docroot) do
            # Ensure that source WordPress is running the latest version
            result = capture :wp, (fetch(:multisite, false) ? "--url=#{fetch(:source_site_multisite_url)}" : ''), 'core', 'check-update'
            unless result.index('Success')
              puts 'Could not copy from source WordPress because it is not running the latest version of WordPress. Please update source before running a copy operation.'
            end
          end

          within fetch(:wp_docroot) do
            # Ensure that destination WordPress is running the latest version
            result = capture :wp, (fetch(:multisite, false) ? "--url=#{fetch(:destination_site_multisite_url)}" : ''), 'core', 'check-update'
            unless result.index('Success')
              puts "Could not copy TO destination [#{fetch(:stage)}] WordPress because it is not running the latest version of WordPress. Please update [#{fetch(:stage)}] before running a copy operation."
            end
          end
        end
        on roles(:web) do

          db_export_tempfile_path = ''

          within fetch(:src_wp_docroot) do
            # On source WordPress...

            # Export source WP DB to a temporary file
            db_export_tempfile_path = Dir::Tmpname.make_tmpname '/tmp/', 'db_export_tempfile.sql'
            execute :wp, (fetch(:multisite, false) ? "--url=#{fetch(:source_site_multisite_url)}" : ''), 'db', 'export', db_export_tempfile_path
          end

          within fetch(:wp_docroot) do
            # On destination WordPress...

            # Drop all tables
            execute :wp, 'db', 'reset', '--yes'

            # Read in db file
            execute :wp, 'db', 'import', db_export_tempfile_path

            # Delete db file now that we're done with it
            execute :rm, db_export_tempfile_path

            # Delete and recreate the wp-content directory
            execute :rm, '-rf', fetch(:wp_content_path)
            execute :mkdir, fetch(:wp_content_path)

            # Copy wp content from source, ignoring .nfs* lock files
            # Note that because we have the '--copy-links' flag below, we're transforming all symlinks into real file copies
            rsync_params = [
              '--recursive',
              '--perms',
              '--times',
              '--devices',
              '--specials',
              '--copy-links'
            ]

            # We're going to be copying wp-content in two parts
            # 1. Everything else under wp-content EXCEPT uploads, blogs.dir,
            # plugins, themes, mu-plugins

            # 2. Everything under uploads AND wpblogs.dir with
            # cul-allowed-upload-types file extension filter applied

            # TODO: Generate file list
            # Include only allowed extensions
            #allowed_upload_file_extensions = JSON.parse(capture(:wp, 'eval', '"echo cul_allowed_upload_file_extensions_as_json();"'))

            # Exclude all repo-managed plugins, mu_plugins and themes
            fetch(:wp_custom_plugins, {}).each do |plugin, repo_relative_path|
              rsync_params << "--exclude plugins/#{plugin}"
            end
            fetch(:wp_custom_mu_plugins, {}).each do |mu_plugin, repo_relative_path|
              rsync_params << "--exclude mu-plugins/#{mu_plugin}"
            end
            fetch(:wp_custom_themes, {}).each do |theme, repo_relative_path|
              rsync_params << "--exclude themes/#{theme}"
            end

            # Exclude cul-allowed-upload-types plugin
            rsync_params << '--exclude ' + path_to_allowed_upload_types_plugin

            # Exclude .nfs* lock files
            rsync_params << '--exclude .nfs*'

            # Exclude Wordfence wflogs directory, if present
            rsync_params << '--exclude wflogs'

            # Exclude repository directories
            rsync_params << '--exclude .svn'
            rsync_params << '--exclude .git'
            rsync_params << '--exclude .hg'

            # Define copy src
            rsync_params << File.join(fetch(:src_wp_docroot), 'wp-content/')

            # Define copy dest
            rsync_params << fetch(:wp_content_path) + '/'

            puts 'Copying wp-content. This may take a while for sites with a lot of uploads, plugins or themes...'

            execute :rsync, *rsync_params

            # Regenerate symlinks
            invoke 'cul:wp:symlink_custom_plugins_and_themes'

            # Make docroot readable and executable for "other" user so nginx, which runs as "nobody", can read
            # Use -L flag because we want to follow symlinks. The whole deployment relies on symlinks.
            execute :find, '-L', File.join(fetch(:wp_docroot), 'wp-content'), '-type d -exec chmod o+rx "{}" \;'
            execute :find, '-L', File.join(fetch(:wp_docroot), 'wp-content'), '-type f -exec chmod o+r "{}" \;'

            # Invoke searchreplace task to update URL
            puts "\nYou'll probably want to run the cul:wp:searchreplace command now, since it's likely that your WP URL differs between environments."
            puts "Do you want to run a search and replace operation?"
            set :confirm_searchreplace, ask('"y" or "yes" to continue')
            if ['y', 'yes'].include?(fetch(:confirm_searchreplace))
              invoke 'cul:wp:searchreplace'
            else
              puts '- Skipping search and replace because neither "y" nor "yes" were entered.'
            end

            puts "\nCopy operation complete!"
          end

        end

      end

      after 'cul:wp:migrate:copy_from', 'cul:wp:disable_maintenance_mode'

    end
  end
end
